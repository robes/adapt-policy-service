package edu.isi.policy;

import org.apache.log4j.Logger;
import edu.isi.policy.entity.Transfer;
import edu.isi.policy.util.TransferList;
import edu.isi.policy.util.IdentityGenerator;

import java.util.Collections;
import java.util.Map;
import java.util.HashMap;

global Logger logger; 
global String third_party_transfer_parallel_default;

# This rule set assumes that the client updates the transfer when it is completed, not
# removing it.  The policy session will keep a STATUS property for transfers with
# the following options:
# START: client should start the transfer
# STARTED: client has been sent the notification to start the transfer
# RUNNING: transfer is running on a client, session has been notified by the client of this
# COMPLETED: transfer is completed, session has been notified by the client of this 
# FAILED: transfer failed, session has been notified by the client of this

rule "Add new requested transfers to knowledge memory"
salience 1000
no-loop
when
  $transferList: TransferList(size() > 0)
  $t: Transfer($id: id, $source: source, $destination: destination, properties["STATUS"] == null) from $transferList
  not Transfer(id != $id, source == $source, destination == $destination, properties["STATUS"] != "FAILED")
then
  $t.setProperty("STATUS", "START");
  insert($t);
  logger.debug("Added transfer " + $t + " to knowledge memory with STATUS=START." );
end

rule "Set property to STARTED to transfers with START status and not on current request"
salience 2000
when
    $transferList: TransferList(size() > 0)
    $t: Transfer(properties["STATUS"] == "START")
    not Transfer(id == $t.id) from $transferList
then
    modify($t) {
      setProperty("STATUS", "STARTED")
    }
    logger.debug("Set previously requested transfer " + $t + " STATUS=STARTED.");
end

rule "Replace requested transfers that have already been started by another process."
no-loop
when
    $transferList: TransferList(size() > 0)
    $t1: Transfer($id:id, $source: source, $destination: destination) from $transferList
    $t2: Transfer(id != $id, source == $source, destination == $destination, properties["STATUS"] != "FAILED")
then
    int $index = $transferList.indexOf($t1);
    modify($transferList) {
      set($index, $t2)
    }
    logger.debug("Replaced requested transfer " + $t1 + " with existing transfer " + $t2);
end

rule "Report and remove failed transfers."
when
    $t: Transfer(properties["STATUS"] == "FAILED")
then
    logger.warn("Failed transfer: " + $t);
    retract($t);
end

rule "Generate staging request map"
when
  not Map(this["_type_"] == "staging")
then
  Map map = new HashMap();
  map.put("_type_", "staging");
  insert(map);
  logger.debug("Added staging map to memory.");
end

rule "Increment counter in staging map for transfer on transfer list"
no-loop
salience -1000 # Do this towards the end
when
  $transferList: TransferList(size() > 0)
  $t: Transfer($destination: destination) from $transferList
  $map: Map(this["_type_"] == "staging")
then
  Integer $n = (Integer)$map.get($destination);
  if($n == null) {
    $n = 1;
  }
  else {
    $n++;
  }
  modify($map) {
    put($destination, $n)
  }
  logger.debug("Incremented staging counter for " + $destination + " to " + $n); 
end

rule "Sort all transfers in the transfer list based on name (default sortable)"
no-loop
salience -1000 # Do this later on in the steps
when
  $transferList: TransferList(size() > 1)
then
  Collections.sort($transferList);
  logger.debug("Sorted transfer list.");
end

rule "Remove duplicate transfers from transfer list."
salience 2000 # Run this in the beginning to save on extra processing later
when
    $transferList: TransferList(size() > 0)
    $t1: Transfer($id: id, $source: source, $destination: destination) from $transferList
    $t2: Transfer(id != $id, source == $source, destination == $destination) from $transferList
then
    modify($transferList) {
      remove($t2)
    }
    logger.debug("Removed transfer " + $t2 + " from transfer list because it is a duplicate of " + $t1);
end

rule "Generate group_id map"
when
  not Map(this["_type_"] == "group_id")
then
  Map map = new HashMap();
  map.put("_type_", "group_id");
  insert(map);
  logger.debug("Added group_id map to memory.");
end

rule "Generate group_id for a protocol host pair"
when
  Transfer(properties["group_id"] == null, $key:(source.getScheme() + "://" + source.getHost() + "-" + destination.getScheme() + "://" + destination.getHost()))
  $map: Map(this["_type_"] == "group_id", this[$key] == null)
then
  String $group_id = IdentityGenerator.generateId();
  modify($map) {
    put($key, $group_id)
  }
  logger.debug("Generated group_id " + $group_id + " for key " + $key);
end

rule "Assign group_id property to transfer"
when
  $t:Transfer(properties["group_id"] == null, $key:(source.getScheme() + "://" + source.getHost() + "-" + destination.getScheme() + "://" + destination.getHost()))
  $map: Map(this["_type_"] == "group_id", this[$key] != null)
then
  String $group_id = (String)$map.get($key);
  modify($t) {
    setProperty("group_id", $group_id)
  }
  logger.debug("Assigned group_id " + $group_id + " to transfer " + $t);
end

rule "Assign parallel level for third-party transfer"
when
  $t:Transfer(properties["parallel"] == null, source.getScheme() == "gsiftp", destination.getScheme() == "gsiftp")
then
  modify($t) {
    setProperty("parallel", third_party_transfer_parallel_default)
  }
  logger.debug("Set parallel=" + third_party_transfer_parallel_default + " for transfer " + $t);
end
