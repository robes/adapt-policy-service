package edu.isi.policy;

import org.apache.log4j.Logger;
import edu.isi.policy.entity.Transfer;
import edu.isi.policy.entity.Resource;
import edu.isi.policy.entity.Cleanup;
import edu.isi.policy.util.TransferList;
import edu.isi.policy.util.CleanupList;
import edu.isi.policy.util.IdentityGenerator;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Collections;

import edu.isi.policy.util.TransferStatisticsLog;

global Logger logger;
global Integer third_party_transfer_parallel_default;
global TransferStatisticsLog transferStatisticsLog;

# This rule set is designed to work with Pegasus workflows.

rule "Add new requested third-party transfers and two-party uploads to knowledge memory"
salience 1000
when
  $transferList: TransferList(size() > 0)
  $t1: Transfer($source:source, destination.getScheme() != "file", $destination:destination, $host:destination.getHost(), $file:destination.getPath()) from $transferList
  not Transfer(destination == $destination)
  not Resource(host == $host, file == $file)
then
  insert($t1);
  if(logger.isInfoEnabled()) {
    logger.info("Added new requested transfer " + $t1);
  }
  transferStatisticsLog.recordNewTransfer($t1);
  if(logger.isDebugEnabled()) {
    logger.debug("Recorded new transfer " + $t1);
  }
end

rule "Add new requested two-party downloads to knowledge memory"
salience 1000
when
  $transferList: TransferList(size() > 0)
  $t1: Transfer($source:source, destination.getScheme() == "file", $destination:destination, $file:destination.getPath(), $local_file_host:properties["local_file_host"]) from $transferList
  not Transfer(destination == $destination, properties["local_file_host"] == $local_file_host)
  not Resource(host == $local_file_host, file == $local_file_host)
then
  insert($t1);
  if(logger.isInfoEnabled()) {
    logger.info("Added new requested transfer " + $t1);
  }
  transferStatisticsLog.recordNewTransfer($t1);
  if(logger.isDebugEnabled()) {
    logger.debug("Recorded new transfer " + $t1);
  }
end

rule "Initialize transfer status to START"
when
  $t: Transfer(properties["STATUS"] == null)
then
  modify($t) {
    setProperty("STATUS", "START")
  }
  if(logger.isDebugEnabled()) {
    logger.debug("Set STATUS=START on transfer " + $t);
  }
end

rule "Initialize cleanup status to START"
when
  $c: Cleanup(properties["STATUS"] == null)
then
  modify($c) {
    setProperty("STATUS", "START")
  }
  if(logger.isDebugEnabled()) {
    logger.debug("Set STATUS=START on cleanup " + $c);
  }
end

rule "Remove duplicate third-party transfers or two-party uploads from list that are already in progress"
salience -900
no-loop
when
  $transferList: TransferList(size() > 0)
  $t1: Transfer(destination.getScheme() != "file", $destination:destination, $host:destination.getHost(), $file:destination.getPath(), $id:id) from $transferList
  not Transfer(id == $id)
  Resource(host == $host, file == $file, jobs contains $id)
then
  modify($transferList) {
    remove($t1)
  }
  if(logger.isInfoEnabled()) {
    logger.info("Removed duplicate transfer " + $t1 + " from the list.");
  }
  transferStatisticsLog.recordDuplicateTransferRequested($t1);
  if(logger.isDebugEnabled()) {
    logger.debug("Recorded duplicated transfer requested: " + $t1);
  }
end

rule "Remove duplicate two-party downloads from list that are already in progress"
salience -900
no-loop
when
  $transferList: TransferList(size() > 0)
  $t1: Transfer(destination.getScheme() == "file", $destination:destination, $file:destination.getPath(), $local_file_host:properties["local_file_host"], $id:id) from $transferList
  not Transfer(id == $id)
  Resource(file == $file, host == $local_file_host)
then
  modify($transferList) {
    remove($t1)
  }
  if(logger.isInfoEnabled()) {
    logger.info("Removed duplicate transfer " + $t1 + " from the list.");
  }
  transferStatisticsLog.recordDuplicateTransferRequested($t1);
  if(logger.isDebugEnabled()) {
    logger.debug("Recorded duplicated transfer requested: " + $t1);
  }
end

rule "Create resource for new third-party transfer or two-party upload"
when
  $transferList: TransferList(size() > 0)
  Transfer($source:source, $rk: destination, destination.getScheme() != "file", $host:destination.getHost(), $file:destination.getPath(), $id:id) from $transferList
  not Transfer(destination == $rk, id != $id)
  not Resource(host == $host, file == $file)
then
  Resource $r = new Resource($host, $file);
  $r.setId(IdentityGenerator.generateId());
  insert($r);
  if(logger.isInfoEnabled()) {
    logger.info("Added new resource " + $r);
  }
end

rule "Create resource for new two-party download"
when
  $transferList: TransferList(size() > 0)
  Transfer($source:source, $destination:destination, destination.getScheme() == "file", $file:destination.getPath(), $local_file_host:properties["local_file_host"] != null, $id:id) from $transferList
  not Transfer(source == $source, destination == $destination, properties["local_file_host"] == $local_file_host, id != $id)
  not Resource(file == $file, host == $local_file_host)
then
  Resource $r = new Resource($local_file_host.toString(), $file);
  $r.setId(IdentityGenerator.generateId());
  insert($r);
  if(logger.isInfoEnabled()) {
    logger.info("Added new resource " + $r);
  }
end

rule "Add third-party or two-party upload transfer job to resource"
when
  $transferList: TransferList(size() > 0)
  $t1:Transfer($id: id, $destination: destination, $host:destination.getHost(), $file:destination.getPath(), destination.getScheme() != "file") from $transferList
  $r: Resource(host == $host, file == $file, jobs not contains $id)
then
  modify($r) {
    addJob($id)
  }
  if(logger.isDebugEnabled()) {
    logger.debug("Added " + $id + " to jobs for " + $r);
  }
end

rule "Add two-party download transfer job to resource"
when
  $transferList: TransferList(size() > 0)
  $t1:Transfer($id: id, $destination: destination, destination.getScheme() == "file", $file:destination.getPath(), $local_file_host:properties["local_file_host"]) from $transferList
  $r: Resource(file == $file, host == $local_file_host, jobs not contains $id)
then
  modify($r) {
    addJob($id)
  }
  if(logger.isDebugEnabled()) {
    logger.debug("Added " + $id + " to jobs for " + $r);
  }
end

rule "Sort all transfers in the transfer list based on name (default sortable)"
salience -1000 # Do this later on in the steps
when
  $transferList: TransferList(size() > 1)
then
  Collections.sort($transferList);
  if(logger.isDebugEnabled()) {
    logger.debug("Sorted transfer list.");
  }
end

rule "Remove transfer list from policy memory"
salience -2000
when
  $transferList:TransferList()
  not Transfer(properties["STATUS"] == null)
then
  retract($transferList);
  if(logger.isDebugEnabled()) {
    logger.debug("Retracted transfer list.");
  }
end

rule "Remove cleanup list from policy memory"
salience -2000
when
  $cleanupList:CleanupList()
then
  retract($cleanupList);
  if(logger.isDebugEnabled()) {
    logger.debug("Retracted cleanup list.");
  }
end

rule "Generate group_id map"
salience 2000
when
  not Map(this["_type_"] == "group_id")
then
  Map map = new ConcurrentHashMap();
  map.put("_type_", "group_id");
  insert(map);
  if(logger.isDebugEnabled()) {
    logger.debug("Added group_id map to memory.");
  }
end

rule "Generate group_id for a protocol host pair"
salience 1000
when
  Transfer(properties["group_id"] == null, $key:(source.getScheme() + "://" + source.getHost() + "-" + destination.getScheme() + "://" + destination.getHost()))
  $map: Map(this["_type_"] == "group_id", this[$key] == null)
then
  String $group_id = IdentityGenerator.generateId();
  modify($map) {
    put($key, $group_id)
  }
  if(logger.isDebugEnabled()) {
    logger.debug("Generated group_id " + $group_id + " for key " + $key);
  }
end

rule "Assign group_id property to transfer"
when
  $t:Transfer(properties["group_id"] == null, $key:(source.getScheme() + "://" + source.getHost() + "-" + destination.getScheme() + "://" + destination.getHost()))
  $map: Map(this["_type_"] == "group_id", this[$key] != null)
then
  String $group_id = (String)$map.get($key);
  modify($t) {
    setProperty("group_id", $group_id)
  }
  if(logger.isDebugEnabled()) {
    logger.debug("Assigned group_id " + $group_id + " to transfer " + $t);
  }
end

rule "Remove remote cleanup from list when resource has multiple pending jobs"
when
  $cleanupList: CleanupList(size() > 0)
  $rc: Cleanup($host:uri.getHost(), $file:uri.getPath(), uri.getScheme() != "file") from $cleanupList
  $r: Resource(host == $host, file == $file, numberOfJobs > 1)
then
  modify($r) {
    decrementNumberOfJobs()
  }
  if(logger.isDebugEnabled()) {
    logger.debug("Decremented number of jobs for resource " + $r + " to " + $r.getNumberOfJobs());
  }
  modify($cleanupList) {
    remove($rc)
  }
  if(logger.isInfoEnabled()) {
    logger.info("Removed cleanup " + $rc + " from list since there are remaining jobs.");
  }
end

rule "Remove local cleanup from list when resource has multiple pending jobs"
when
  $cleanupList: CleanupList(size() > 0)
  $rc: Cleanup(uri.getScheme() == "file", $file:uri.getPath(), $local_file_host:properties["local_file_host"]) from $cleanupList
  $r: Resource(file == $file, host == $local_file_host, numberOfJobs > 1)
then
  modify($r) {
    decrementNumberOfJobs()
  }
  if(logger.isDebugEnabled()) {
    logger.debug("Decremented number of jobs for resource " + $r + " to " + $r.getNumberOfJobs());
  }
  modify($cleanupList) {
    remove($rc)
  }
  if(logger.isInfoEnabled()) {
    logger.info("Removed cleanup " + $rc + " from list since there are remaining jobs.");
  }
end

rule "Remove remote resource when cleanup is requested from the last job"
when
  $cleanupList: CleanupList(size() > 0)
  $rc: Cleanup($host:uri.getHost(), $file:uri.getPath(), uri.getScheme() != "file") from $cleanupList
  $r: Resource(host == $host, file == $file, numberOfJobs == 1)
then
  insert($rc);
  if(logger.isInfoEnabled()) {
    logger.info("Added cleanup " + $rc + " to knowledge session.");
  }
  retract($r);
  if(logger.isInfoEnabled()) {
    logger.info("Removed resource " + $r + " from knowledge.");
  }
  transferStatisticsLog.recordNewCleanup($rc);
  if(logger.isDebugEnabled()) {
    logger.debug("Recorded new cleanup " + $rc);
  }
end

rule "Store remote file cleanup when resource is not known"
when
  $cleanupList: CleanupList(size() > 0)
  $rc: Cleanup($host:uri.getHost(), $file:uri.getPath(), uri.getScheme() != "file") from $cleanupList
  not Resource(host == $host, file == $file)
then
  insert($rc);
  if(logger.isInfoEnabled()) {
    logger.info("Added cleanup " + $rc + " to knowledge session.");
  }
  transferStatisticsLog.recordNewCleanup($rc);
  if(logger.isDebugEnabled()) {
    logger.debug("Recorded new cleanup " + $rc);
  }
end

rule "Store local file cleanup when resource is not known"
when
  $cleanupList: CleanupList(size() > 0)
  $rc:Cleanup(uri.getScheme() == "file", $file:uri.getPath(), $local_file_host:properties["local_file_host"]) from $cleanupList
  not Resource(file == $file, host == $local_file_host)
then
  insert($rc);
  if(logger.isInfoEnabled()) {
    logger.info("Added cleanup " + $rc + " to knowledge session.");
  }
  transferStatisticsLog.recordNewCleanup($rc);
  if(logger.isDebugEnabled()) {
    logger.debug("Recorded new cleanup " + $rc);
  }
end

rule "Remove local resource when cleanup is requested from the last job"
when
  $cleanupList: CleanupList(size() > 0)
  $rc: Cleanup(uri.getScheme() == "file", $file:uri.getPath(), $local_file_host:properties["local_file_host"]) from $cleanupList
  $r: Resource(file == $file, host == $local_file_host, numberOfJobs == 1)
then
  insert($rc);
  if(logger.isInfoEnabled()) {
    logger.info("Added cleanup " + $rc + " to knowledge session.");
  }
  retract($r);
  if(logger.isInfoEnabled()) {
    logger.info("Removed resource " + $r + " from knowledge.");
  }
  transferStatisticsLog.recordNewCleanup($rc);
  if(logger.isDebugEnabled()) {
    logger.debug("Recorded new cleanup " + $rc);
  }
end

rule "Assign default parallel level"
when
  $t:Transfer(properties["parallel"] == null, properties["STATUS"] != "COMPLETED", properties["parallel"] == null)
then
  modify($t) {
    setProperty("parallel", third_party_transfer_parallel_default.toString())
  }
  if(logger.isDebugEnabled()) {
    logger.debug("Set parallel=" + third_party_transfer_parallel_default + " for transfer " + $t);
  }
end

rule "Remove completed transfer"
when
  $t: Transfer(properties["STATUS"] == "COMPLETED")
then
  retract($t);
  if(logger.isDebugEnabled()) {
    logger.debug("Removed completed transfer " + $t);
  }
  transferStatisticsLog.recordTransferCompleted($t);
  if(logger.isDebugEnabled()) {
    logger.debug("Recorded transfer completed: " + $t);
  }
end

rule "Remove completed cleanup"
when
  $c:Cleanup(properties["STATUS"] == "COMPLETED")
then
  retract($c);
  if(logger.isInfoEnabled()) {
    logger.info("Removed completed cleanup " + $c);
  }
  transferStatisticsLog.recordCleanupCompleted($c);
  if(logger.isDebugEnabled()) {
    logger.debug("Recorded duplicated transfer requested: " + $c);
  }
end

rule "Remove failed third party transfer"
when
  $t: Transfer(destination.getScheme() != "file", $host:destination.getHost(), $file:destination.getPath(), properties["STATUS"] == "FAILED")
  $r: Resource(host == $host, file == $file)
then
  retract($t);
  if(logger.isDebugEnabled()) {
    logger.debug("Removed failed transfer " + $t);
  }
  retract($r);
  if(logger.isDebugEnabled()) {
    logger.debug("Removed resource " + $r + " because its transfer failed.");
  }
  transferStatisticsLog.recordTransferFailed($t);
  if(logger.isDebugEnabled()) {
    logger.debug("Recorded failed transfer: " + $t);
  }
end

rule "Remove failed two party download"
when
  $t: Transfer(destination.getScheme() == "file", $file:destination.getPath(), $local_file_host:properties["local_file_host"], properties["STATUS"] == "FAILED")
  $r: Resource(file == $file, host == $local_file_host)
then
  retract($t);
  if(logger.isDebugEnabled()) {
    logger.debug("Removed failed transfer " + $t);
  }
  retract($r);
  if(logger.isDebugEnabled()) {
    logger.debug("Removed resource " + $r + " because its transfer failed.");
  }
  transferStatisticsLog.recordTransferFailed($t);
  if(logger.isDebugEnabled()) {
    logger.debug("Recorded failed transfer: " + $t);
  }
end

rule "Clear group_id map"
no-loop
salience -10000
when
  $m: Map(this["_type_"] == "group_id")
  not Transfer(properties["group_id"] == null)
then
  modify($m) {
    clear(),
    put("_type_", "group_id")
  }
  if(logger.isDebugEnabled()) {
    logger.debug("Cleared group_id map.");
  }
end

rule "Ensure transfer has at least 1 parallel stream"
when
  $t: Transfer(properties["parallel"] == 0, properties["STATUS"] == null)
then
  modify($t) {
    setProperty("parallel", "1")
  }
  if(logger.isDebugEnabled()) {
    logger.debug("Set parallel=1 for transfer " + $t + " because it was set to 0.");
  }
end